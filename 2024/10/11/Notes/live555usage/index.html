



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Sunday" href="http://hexlove2.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Sunday" href="http://hexlove2.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="Sunday" href="http://hexlove2.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="live555, ffmpeg" />


<link rel="canonical" href="http://hexlove2.github.io/2024/10/11/Notes/live555usage/">



  <title>
Live555 Usage(FFmpeg) - Notes |
Hex = Sunday = Later's better than never</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Live555 Usage(FFmpeg)
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2024-10-12 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2024-10-12T00:00:00+09:00">2024-10-12</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Hex</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://raw.githubusercontent.com/Hexlove2/images1/main/images2/33.jpg"></li>
          <li class="item" data-background-image="https://raw.githubusercontent.com/Hexlove2/images1/main/images2/11.jpg"></li>
          <li class="item" data-background-image="https://raw.githubusercontent.com/Hexlove2/images1/main/images2/10.jpg"></li>
          <li class="item" data-background-image="https://raw.githubusercontent.com/Hexlove2/images1/main/images2/13.jpg"></li>
          <li class="item" data-background-image="https://raw.githubusercontent.com/Hexlove2/images1/main/images2/28.jpg"></li>
          <li class="item" data-background-image="https://raw.githubusercontent.com/Hexlove2/images1/main/images2/14.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Notes/" itemprop="item" rel="index" title="In Notes"><span itemprop="name">Notes</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://hexlove2.github.io/2024/10/11/Notes/live555usage/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Sunday">
    <meta itemprop="description" content="Later's better than never, Later's better than never">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Sunday">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h3 id="platform-win10-macos15"><a class="markdownIt-Anchor" href="#platform-win10-macos15">#</a> Platform: Win10 &amp; MacOS15</h3>
<h3 id="reference-ffmpeg-live555"><a class="markdownIt-Anchor" href="#reference-ffmpeg-live555">#</a> Reference: FFMPEG, LIVE555</h3>
<h3 id="1-source-code-download-link-httpsgithubcomrgaufmanlive555"><a class="markdownIt-Anchor" href="#1-source-code-download-link-httpsgithubcomrgaufmanlive555">#</a> 1. Source Code Download Link: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JnYXVmbWFuL2xpdmU1NTU=">https://github.com/rgaufman/live555</span></h3>
<p>This repository was not published by the original team of Live555, but I can’t download it on their website. You can also try it before using this link to get the newest version.</p>
<h3 id="2-build"><a class="markdownIt-Anchor" href="#2-build">#</a> 2. Build</h3>
<p>Unzip the file or use git, then you’ll get a folder including these files like this below. Then open it on the terminal.</p>
<p><img data-src="https://raw.githubusercontent.com/Hexlove2/images1/main/images/Screenshot%202024-10-12%20at%205.19.16%E2%80%AFPM.png" alt="Screenshot 2024-10-12 at 5.19.16 PM"></p>
<p>Then input</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
<span class="token builtin class-name">cd</span> live555
<span class="token comment"># if your platform is linux</span>
./genMakefiles linux
<span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img data-src="https://raw.githubusercontent.com/Hexlove2/images1/main/images/Screenshot%202024-10-12%20at%205.22.22%E2%80%AFPM.png" alt="Screenshot 2024-10-12 at 5.22.22 PM"></p>
<p>Because my platform is Mac, so I need to choose this one.</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
./genMakefiles macosx-bigsur
<span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>You can also look through some examples provided by the team in the folder named testProgs.</p>
<p>There is a clear and good example of a cpp file named testOnDemandRTSPServer.cpp.</p>
<h3 id="3-usages"><a class="markdownIt-Anchor" href="#3-usages">#</a> 3. Usages</h3>
<h4 id="1-push-local-audio-and-video-files-stream-to-an-rtsp-server"><a class="markdownIt-Anchor" href="#1-push-local-audio-and-video-files-stream-to-an-rtsp-server">#</a> 1. Push local audio and video files’ stream to an RTSP server.</h4>
<p>So, in order to do that, what you need to do first is just create an RTSP server, here is a template, and I will add some explanations in the code below.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;
#include &quot;liveMedia.h&quot;
#include &quot;BasicUsageEnvironment.h&quot;
#include &quot;GroupsockHelper.h&quot;
using namespace std;

int main(int argc, char** argv) &#123;
    &#x2F;&#x2F; Setting the basic environment.
    &#x2F;&#x2F; cout &lt;&lt; &quot;Hello, World&quot;; Just a test, never mind.
    TaskScheduler* scheduler &#x3D; BasicTaskScheduler::createNew();
    UsageEnvironment* env &#x3D; BasicUsageEnvironment::createNew(*scheduler);

    &#x2F;&#x2F; Create the RTSP server 
    char const* rtspURL &#x3D; &quot;rtsp:&#x2F;&#x2F;127.0.0.1:8554&#x2F;liveTest&quot;;
    RTSPServer* rtspServer &#x3D; RTSPServer::createNew(*env, 8554);

    if (rtspServer &#x3D;&#x3D; nullptr) &#123;
        *env &lt;&lt; &quot;Failed to create RTSP client: &quot; &lt;&lt; env-&gt;getResultMsg() &lt;&lt; &quot;\n&quot;;
        exit(1);
    &#125;

    &#123;
        char const* streamName    &#x3D; &quot;liveTest&quot;;
        char const* videoFileName &#x3D; &quot;test.264&quot;;
        char const* audioFileName &#x3D; &quot;test.aac&quot;;
        ServerMediaSession* sms &#x3D; ServerMediaSession::createNew(*env, streamName, streamName);
        sms-&gt;addSubsession(H264VideoFileServerMediaSubsession::createNew(*env, videoFileName, False));

        sms-&gt;addSubsession(ADTSAudioFileServerMediaSubsession::createNew(*env, audioFileName, False));
        rtspServer-&gt;addServerMediaSession(sms);
        &#x2F;&#x2F; announceStream();
    &#125;
  
    &#x2F;&#x2F; Event Loop
    env-&gt;taskScheduler().doEventLoop();

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Btw, you need to prepare both the source audio and video files in advance in the folder of your final executable file just like this</p>
<p><img data-src="https://raw.githubusercontent.com/Hexlove2/images1/main/images/e39485eaad25fd4b7de3ed8d976a2fdc.png" alt="e39485eaad25fd4b7de3ed8d976a2fdc"></p>
<p>test.264 and test.aac.</p>
<p>If you just want to have a test and you don’t have any files like these, you can download any mp4 format video and extract the audio and video parts into these files. You can use a FFmpeg command line like this:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
ffmpeg <span class="token parameter variable">-i</span> input.mp4 <span class="token parameter variable">-c:v</span> copy <span class="token parameter variable">-an</span> <span class="token parameter variable">-bsf:v</span> h264_mp4toannexb test.264 <span class="token parameter variable">-c:a</span> copy <span class="token parameter variable">-vn</span> test.aac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>You only need to download some test videos and name them input.mp4, then execute this command on your terminal.</p>
<p>You can test it on any app that can watch the RTSP stream. Like the pot player, or you can just execute this command:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">
ffplay rtsp://192.168.1.18:8554/liveTest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Remember to replace the IP. If you test it on the same device, you should replace it with 127.0.0.1</p>
<p>Alright, this example is tiny and concise, Let’s discuss another situation when you need to customize your own source like a camera source.</p>
<h4 id="2-push-the-camera-stream-to-an-rtsp-server"><a class="markdownIt-Anchor" href="#2-push-the-camera-stream-to-an-rtsp-server">#</a> 2. Push the camera stream to an RTSP server.</h4>
<p>This demand is way harder if you haven’t used it before. So first of all, you need a camera source, which means you need to have a place to get the data and send them to the source, you can use OpenCV or FFmpeg to get H264 data, it’s not the point we should talk about here.</p>
<p>Suppose we have a source like this:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int decodec_packet_cb(video_packet * packet, void * userdata)
&#123;    
  	bool live_On &#x3D; true;
    if (live_On)
    &#123;   
      	&#x2F;&#x2F;send the data
        sender_data_cb(&amp;x_rtspHandle, packet-&gt;buf, packet-&gt;len);
    &#125;
  	&#x2F;&#x2F;This is for decoding
    return lb_videocodec_packet_cb(packet, userdata);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>First of all, open the server.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int main()
&#123;
  &#x2F;&#x2F;capture thread
  &#x2F;&#x2F;.
  &#x2F;&#x2F;encode thread
  &#x2F;&#x2F;.
  void* rtspHandle;
  rtsp_create(&amp;rtspHandle);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Create the thread.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int rtsp_create(void ** handle)
&#123;
    std::thread rtsp_thread(rtsp_proc_xyh, handle);
    rtsp_thread.detach();
    &#123;
        std::unique_lock&lt;std::mutex&gt; lk(cv_m2);
        cv2.wait(lk, [] &#123;return ready; &#125;);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Here is the code of the thread</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
static int rtsp_proc_xyh(void ** handle)
&#123;
    TaskScheduler* scheduler &#x3D; BasicTaskScheduler::createNew();
    UsageEnvironment* env &#x3D; BasicUsageEnvironment::createNew(*scheduler);

    RTSPServer* rtspServer &#x3D; RTSPServer::createNew(*env, 8554);
    if (!rtspServer) &#123;
        *env &lt;&lt; &quot;failed to create RTSP server: &quot; &lt;&lt; env-&gt;getResultMsg() &lt;&lt; &quot;\n&quot;;
        SLOG_ERROR(&quot;failed to create RTSP server: %s&quot;, env-&gt;getResultMsg());
        exit(1);
    &#125;

    ServerMediaSession* sms &#x3D; ServerMediaSession::createNew(*env, &quot;liveStream&quot;, &quot;liveStream&quot;, &quot;H.264 stream&quot;);
    XyhCapLiveServerMediaSession* LiveSession &#x3D; XyhCapLiveServerMediaSession::createNew(*env, NULL, false);
    sms-&gt;addSubsession(LiveSession);
    rtspServer-&gt;addServerMediaSession(sms);
    *handle &#x3D; LiveSession;
    *env &lt;&lt; &quot;Stream ready at rtsp:&#x2F;&#x2F;127.0.0.1:8554&#x2F;liveStream\n&quot;;
    
    &#123;
        std::lock_guard&lt;std::mutex&gt; lk(cv_m2);
        ready &#x3D; true;
    &#125;
    cv2.notify_one();
    env-&gt;taskScheduler().doEventLoop();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>You can notice that there is a customized class: XyhCapLiveServerMediaSession</p>
<p>Here is the code for this class</p>
<p>OnDemandServerMediaSubsession is the base class.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class XyhCapLiveServerMediaSession : public OnDemandServerMediaSubsession
&#123;

public:
    static XyhCapLiveServerMediaSession* createNew(UsageEnvironment&amp; env, char const* fileName, Boolean reuseFirstSource)
    &#123;
        return new XyhCapLiveServerMediaSession(env, reuseFirstSource);
    &#125;
    
    XyhframeSource* getSource()
    &#123;
        return framesource;
    &#125;
public:
    bool isReady;
protected:
    XyhCapLiveServerMediaSession(UsageEnvironment&amp; env, Boolean reuseFirstSource) : OnDemandServerMediaSubsession(env, reuseFirstSource) &#123;&#125;
    virtual ~XyhCapLiveServerMediaSession()
    &#123;
        &#x2F;&#x2F;delete[] fAuxSDPLine;
    &#125;

protected:
    virtual char const* getAuxSDPLine(RTPSink* rtpSink, FramedSource* inputSource) override;
    virtual FramedSource* createNewStreamSource(unsigned clientSessionId, unsigned&amp; estBitrate) override;
    virtual RTPSink* createNewRTPSink(Groupsock* rtpGroupsock, unsigned char rtpPayLoadTypeIfDynamic, FramedSource* inputSource) override;

private:
    char* fAuxSDPLine;
    char fDoneFlag;
    RTPSink* fDummyRTPSink;
    XyhframeSource* framesource;
&#125;;

FramedSource* XyhCapLiveServerMediaSession::createNewStreamSource(unsigned clientSessionId, unsigned&amp; estBitrate)
&#123;
    estBitrate &#x3D; 500;

    XyhframeSource* videoSource &#x3D; XyhframeSource::createNew(envir());
    if (!videoSource)
    &#123;
        return NULL;
    &#125;
    framesource &#x3D; videoSource;
    isReady &#x3D; true;
&#x2F;&#x2F;    return H264VideoStreamFramer::createNew(envir(), videoSource);
    return videoSource;
&#125;

RTPSink* XyhCapLiveServerMediaSession::createNewRTPSink(Groupsock* rtpGroupsock, unsigned char rtpPayLoadTypeIfDynamic, FramedSource* inputSource)
&#123;
    return H264VideoRTPSink::createNew(envir(), rtpGroupsock, rtpPayLoadTypeIfDynamic);
&#125;

char const* XyhCapLiveServerMediaSession::getAuxSDPLine(RTPSink* rtpSink, FramedSource* inputSource)
&#123;
    return NULL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The other class you need to customize is Framesource. I named it XyhframeSource here.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class XyhframeSource : public FramedSource
&#123;
public:
    int is_run;
    static XyhframeSource* createNew(UsageEnvironment&amp; env)
    &#123;
        return new XyhframeSource(env);
    &#125;

    void send_data(void*data, size_t size)
    &#123;
        try
        &#123;
            std::unique_lock&lt;std::mutex&gt; lock(mutex);
            uint8_t* copiedData &#x3D; new uint8_t[size];
            memcpy(copiedData, data, size);
            nalQueue.push(std::make_pair(copiedData, size));
            cv.notify_one();
        &#125;
        catch(const std::system_error&amp; e)&#123;
            std::cerr &lt;&lt; &quot;Error222: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
        &#125;
    &#125;

protected:
    XyhframeSource(UsageEnvironment&amp; env) : FramedSource(env), nalData(nullptr), nalSize(0) 
    &#123;
            fFrameSize &#x3D; 0;
    &#125;

    virtual ~XyhframeSource() &#123;&#125;

    virtual void doGetNextFrame() override
    &#123;
        ready2 &#x3D; true;
        try &#123;
            std::unique_lock&lt;std::mutex&gt; lock(mutex);
            cv.wait(lock, [this]() &#123;return !nalQueue.empty(); &#125;);

            auto nalUnit &#x3D; nalQueue.front();
            nalQueue.pop();

            nalData &#x3D; nalUnit.first;
            nalSize &#x3D; nalUnit.second;
            if (nalSize &gt; fMaxSize) return;
        &#x2F;&#x2F;    std::cout &lt;&lt; &quot;FMAX: &quot; &lt;&lt; fMaxSize &lt;&lt; &quot;  CURRENT SIZE: &quot; &lt;&lt; nalSize &lt;&lt; std::endl;
            memmove(fTo, nalData, nalSize);
            fFrameSize &#x3D; nalSize;

            delete[] nalData;
            nalData &#x3D; nullptr;

            gettimeofday(&amp;fPresentationTime, nullptr);

            FramedSource::afterGetting(this);
        &#125;
        catch(const std::system_error&amp; e)&#123;
            std::cerr &lt;&lt; &quot;Error111: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
        &#125;         
    &#125;

    virtual void doStopGettingFrames() override
    &#123;
        std::cout &lt;&lt; &quot;STOP GETTING FRAMES&quot; &lt;&lt; std::endl;
    &#125;
private:
    std::queue&lt;std::pair&lt;uint8_t*, int&gt;&gt; nalQueue;
    std::mutex mutex;
    std::condition_variable cv;
    uint8_t* nalData;
    size_t nalSize;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Ok, that’s it. Contact me if you have any problems through my GitHub account, you can see it on my homepage.</p>
<h4 id="3-rtsp-client-receive-rtsp-stream-data-in-h264-format-and-re-encode-it-into-h265"><a class="markdownIt-Anchor" href="#3-rtsp-client-receive-rtsp-stream-data-in-h264-format-and-re-encode-it-into-h265">#</a> 3. RTSP Client: Receive RTSP stream data in H.264 format and re-encode it into H.265</h4>
<p>First of all, we need to create an RTSP Client using live555. Once the server is open, we can receive packets in H264 format. Here is an example demonstrating how to receive them and save them as a .h264 file. In addition, I also converted them into H265 format and save them as a .h265 file. Here is the structure of this program. I’ve pushed this publicly on my Github, and here is the link.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hleGxvdmUyL3J0c3BDbGllbnQ=">https://github.com/Hexlove2/rtspClient</span></p>
<img data-src="https://raw.githubusercontent.com/Hexlove2/images1/main/images/Screenshot%202024-10-18%20at%203.57.52%E2%80%AFPM.png" width="500"/>
<p>And here is the code:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;*
Data: 2024&#x2F;10&#x2F;14
Sunday Myers
*&#x2F;

&#x2F;&#x2F; C++
#include &lt;condition_variable&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;

&#x2F;&#x2F; live555
#include &quot;BasicUsageEnvironment.hh&quot;
#include &quot;liveMedia.hh&quot;

&#x2F;&#x2F; ffmpeg
extern &quot;C&quot; &#123;
#include &quot;libavcodec&#x2F;avcodec.h&quot;
&#125;

#define maxFrame 50
&#x2F;&#x2F; client-&gt;&gt;server: DESCRIBE
&#x2F;&#x2F; server-&gt;&gt;client: 200 OK (SDP)
&#x2F;&#x2F; client-&gt;&gt;server: SETUP
&#x2F;&#x2F; server-&gt;&gt;client: 200 OK
&#x2F;&#x2F; client-&gt;&gt;server: PLAY
&#x2F;&#x2F; server-&gt;&gt;client: RTP&#x2F; client-&gt;&gt;server: TERADOWN
struct FrameData &#123;
  int width;
  int height;
  AVPixelFormat format;
  int FPS;
&#125;;

std::queue&lt;std::pair&lt;uint8_t *, int&gt;&gt; queue264;
std::queue&lt;AVFrame *&gt; queueFrame;
std::queue&lt;std::pair&lt;uint8_t *, int&gt;&gt; queue265;

std::mutex mutex1;
std::mutex mutex2;
std::mutex mutex3;
std::mutex m_set;

std::condition_variable cv1;
std::condition_variable cv2;
std::condition_variable cv3;
std::condition_variable cv_set;

Boolean is_run1;
Boolean is_run2;
Boolean is_run3;

struct FrameData fd;
int count264;
std::ostringstream oss;
Boolean set;

void continueAfterDESCRIBE(RTSPClient *rtspClient, int resultCode,
                           char *resultString);
void continueAfterSETUP(RTSPClient *rtspClient, int resultCode,
                        char *resultString);
void continueAfterPLAY(RTSPClient *rtspClient, int resultCode,
                       char *resultString);

void subsessionAfterPlaying(void *clientData);
void subsessionByeHandler(void *clientData, char const *reason);

void streamTimerHandler(void *clientData);

void openURL(UsageEnvironment &amp;env, char const *progName, char const *rtspURL);

void setupNextSubsession(RTSPClient *rtspClient);

void shutdownStream(RTSPClient *rtspClient, int exitCode &#x3D; 1);

void thread_decode();

void thread_codec();

void thread_save();

UsageEnvironment &amp;operator&lt;&lt;(UsageEnvironment &amp;env,
                             const RTSPClient &amp;rtspClient) &#123;
  return env &lt;&lt; &quot;[URL:\&quot;&quot; &lt;&lt; rtspClient.url() &lt;&lt; &quot;\&quot;];&quot;;
&#125;

UsageEnvironment &amp;operator&lt;&lt;(UsageEnvironment &amp;env,
                             const MediaSubsession &amp;subsession) &#123;
  return env &lt;&lt; subsession.mediumName() &lt;&lt; &quot;&#x2F;&quot; &lt;&lt; subsession.codecName();
&#125;

void usage(UsageEnvironment &amp;env, char const *progName) &#123;
  env &lt;&lt; &quot;Usage: &quot; &lt;&lt; progName &lt;&lt; &quot;&lt;rtsp-url-1&gt;...&lt;rtsp-url-N \n&quot;;
&#125;

&#x2F;&#x2F; Loop exit if this variable change
char eventLoopWatchVariable &#x3D; 0;

class StreamClientState &#123;
public:
  StreamClientState();
  virtual ~StreamClientState();

public:
  &#x2F;&#x2F; Through iter, the client can sequentially access each subsession and
  &#x2F;&#x2F; perform opeartions like SETUP, PLAY.
  MediaSubsessionIterator *iter;
  MediaSession *session;
  MediaSubsession *subsession;

  &#x2F;&#x2F; You can use streamTimerTask to set and cancle timer tasks
  TaskToken streamTimerTask;
  double duration;
&#125;;
int main(int argc, char **argv) &#123;
  TaskScheduler *scheduler &#x3D; BasicTaskScheduler::createNew();
  UsageEnvironment *env &#x3D; BasicUsageEnvironment::createNew(*scheduler);

  count264 &#x3D; 0;

  &#x2F;&#x2F; Get current time
  auto now &#x3D; std::chrono::system_clock::now();
  std::time_t currentTime &#x3D; std::chrono::system_clock::to_time_t(now);

  &#x2F;&#x2F; Use stringstream to format the time into a string
  oss &lt;&lt; std::put_time(std::localtime(&amp;currentTime), &quot;%H:%M&quot;);  

  is_run1 &#x3D; true;
  std::thread decode(thread_decode);
  decode.detach();

  is_run2 &#x3D; true;
  std::thread encode(thread_codec);
  encode.detach();

  is_run3 &#x3D; true;
  std::thread save(thread_save);
  save.detach();

  if (argc &lt; 2) &#123;
    usage(*env, argv[0]);
    return 0;
  &#125;
  &#x2F;&#x2F; Connect to every server
  for (int i &#x3D; 1; i &lt;&#x3D; argc - 1; i++) &#123;
    openURL(*env, argv[0], argv[i]);
  &#125;

  env-&gt;taskScheduler().doEventLoop(&amp;eventLoopWatchVariable);
  return 0;
&#125;

class ourRTSPClient : public RTSPClient &#123;
public:
  static ourRTSPClient *createNew(UsageEnvironment &amp;env, char const *rtspURL,
                                  int verbosityLevel &#x3D; 0,
                                  char const *applicationName &#x3D; NULL,
                                  portNumBits tunnelOverHTTPPortNum &#x3D; 0);

protected:
  ourRTSPClient(UsageEnvironment &amp;env, char const *rtspURL, int verbosityLevel,
                char const *applicationName, portNumBits tunnelOverHTTPPortNum);
  virtual ~ourRTSPClient();

public:
  StreamClientState scs;
&#125;;

class DummySink : public MediaSink &#123;
public:
  static DummySink *createNew(UsageEnvironment &amp;env,
                              MediaSubsession &amp;subsession,
                              char const *streamId &#x3D; NULL);

private:
  DummySink(UsageEnvironment &amp;env, MediaSubsession &amp;subsession,
            char const *streamId);
  virtual ~DummySink();

  static void afterGettingFrame(void *clientData, unsigned frameSize,
                                unsigned numTruncatedBytes,
                                struct timeval presentationTime,
                                unsigned durationInMicroseconds);
  void afterGettingFrame(unsigned frameSize, unsigned numTruncatedBytes,
                         struct timeval presentationTime,
                         unsigned durationInMicroseconds);

private:
  virtual Boolean continuePlaying();

private:
  u_int8_t *fReceiveBuffer;
  MediaSubsession &amp;fSubsession;
  char *fStreamId;
  FILE *fOutputFile;
&#125;;

#define RTSP_CLIENT_VERBOSITY_LEVEL 1

static unsigned rtspClientCount &#x3D; 0;

void openURL(UsageEnvironment &amp;env, char const *progName, char const *rtspURL) &#123;

  RTSPClient *rtspClient &#x3D; ourRTSPClient::createNew(
      env, rtspURL, RTSP_CLIENT_VERBOSITY_LEVEL, progName);
  if (rtspClient &#x3D;&#x3D; NULL) &#123;
    env &lt;&lt; &quot;Failed to create a RTSP client for URL \&quot;&quot; &lt;&lt; rtspURL
        &lt;&lt; &quot;\&quot;:&quot; &lt;&lt; env.getResultMsg() &lt;&lt; &quot;\n&quot;;
    return;
  &#125;

  ++rtspClientCount;
  rtspClient-&gt;sendDescribeCommand(continueAfterDESCRIBE);
&#125;

&#x2F;&#x2F; It&#39;s a callback function that get triggered when the DESCRIBE response is
&#x2F;&#x2F; received from the server The DESCRIBE command is used to request a
&#x2F;&#x2F; description of the media stream in SDP format
void continueAfterDESCRIBE(RTSPClient *rtspClient, int resultCode,
                           char *resultString) &#123;

  do &#123;
    UsageEnvironment &amp;env &#x3D; rtspClient-&gt;envir();
    StreamClientState &amp;scs &#x3D; ((ourRTSPClient *)rtspClient)-&gt;scs;

    if (resultCode !&#x3D; 0) &#123;
      env &lt;&lt; *rtspClient &lt;&lt; &quot;Failed to get a SDP description: &quot; &lt;&lt; resultString
          &lt;&lt; &quot;\n&quot;;
      delete[] resultString;
      break;
    &#125;

    char *const sdpDescription &#x3D; resultString;
    env &lt;&lt; *rtspClient &lt;&lt; &quot;Got a SDP description:\n&quot; &lt;&lt; sdpDescription &lt;&lt; &quot;\n&quot;;

    scs.session &#x3D; MediaSession::createNew(env, sdpDescription);
    delete[] sdpDescription;
    if (scs.session &#x3D;&#x3D; NULL) &#123;
      env &lt;&lt; *rtspClient
          &lt;&lt; &quot;Failed to create a mediasession object from the SDP description&quot;
          &lt;&lt; env.getResultMsg() &lt;&lt; &quot;\n&quot;;
      break;
    &#125; else if (!scs.session-&gt;hasSubsessions()) &#123;
      env &lt;&lt; *rtspClient &lt;&lt; &quot;This session has no media subsessions \n&quot;;
      break;
    &#125;

    &#x2F;&#x2F; Then, create and set up our data source objects for the session. We do
    &#x2F;&#x2F; this by iterating over the session&#39;s subsessions. calling
    &#x2F;&#x2F; &quot;MediaSubsession::initiate()&quot;, and then sending a RTSP &quot;SETUP&quot; command,
    &#x2F;&#x2F; on each one (Each &#39;subsession&#39; will have its own data source)
    scs.iter &#x3D; new MediaSubsessionIterator(*scs.session);
    setupNextSubsession(rtspClient);

    &#x2F;&#x2F; SUCESS
    return;
  &#125; while (0);

  &#x2F;&#x2F; Unknown and Unrecoverable ERROR occured with this stream
  shutdownStream(rtspClient);
&#125;

&#x2F;&#x2F; By default, we request that the server stream its data using RTP&#x2F;UDP.
&#x2F;&#x2F; If, instead, you want to request that the server stream via RTP over TCP,
&#x2F;&#x2F; changing the following to TRUE. Ensure that the server you wanna connect
&#x2F;&#x2F; supports RTP&#x2F;TCP, Otherwise, the RTSP server will most likely reject the
&#x2F;&#x2F; request during the RTSP SETUP phase.
#define REQUEST_STREAM_OVER_TCP False

&#x2F;&#x2F; its primary goal is to iterate through all media subsessions within an RTSP
&#x2F;&#x2F; mediasession, initiate each subsession, and send an RTSP SETUP command for
&#x2F;&#x2F; each one. After all subsessions are set up, it finally sends a PLAY command
&#x2F;&#x2F; to start streaming.
void setupNextSubsession(RTSPClient *rtspClient) &#123;

  &#x2F;&#x2F; Alias
  UsageEnvironment &amp;env &#x3D; rtspClient-&gt;envir();
  StreamClientState &amp;scs &#x3D; ((ourRTSPClient *)rtspClient)-&gt;scs;

  scs.subsession &#x3D; scs.iter-&gt;next();
  if (scs.subsession !&#x3D; NULL) &#123;
    if (!scs.subsession-&gt;initiate()) &#123;
      env &lt;&lt; *rtspClient &lt;&lt; &quot;Failed to initiate the\&quot;&quot; &lt;&lt; *scs.subsession
          &lt;&lt; &quot;\&quot; subsession: &quot; &lt;&lt; env.getResultMsg() &lt;&lt; &quot;\n&quot;;
      setupNextSubsession(
          rtspClient); &#x2F;&#x2F; give up on this subsession; go to the next one
    &#125; else &#123;
      env &lt;&lt; *rtspClient &lt;&lt; &quot;Initiated the \&quot;&quot; &lt;&lt; *scs.subsession
          &lt;&lt; &quot;\&quot; subsession (&quot;;
      if (scs.subsession-&gt;rtcpIsMuxed()) &#123;
        env &lt;&lt; &quot;client port &quot; &lt;&lt; scs.subsession-&gt;clientPortNum();
      &#125; else &#123;
        env &lt;&lt; &quot;client ports &quot; &lt;&lt; scs.subsession-&gt;clientPortNum() &lt;&lt; &quot;-&quot;
            &lt;&lt; scs.subsession-&gt;clientPortNum() + 1;
      &#125;
      env &lt;&lt; &quot;\n&quot;;

      &#x2F;&#x2F; Continue setting up this subsession, by sending a &quot;SETUP&quot; command;
      rtspClient-&gt;sendSetupCommand(*scs.subsession, continueAfterSETUP, False,
                                   REQUEST_STREAM_OVER_TCP);
    &#125;
    return;
  &#125;

  &#x2F;&#x2F; We&#39;ve finished all of the subsession. Now, send a RTSP &quot;PLAY&quot; command to
  &#x2F;&#x2F; start streaming:
  if (scs.session-&gt;absStartTime() !&#x3D; NULL) &#123;
    &#x2F;&#x2F; Special case: The stream is indexed by &#39;absolute time&#39;, so send a
    &#x2F;&#x2F; appropriate &quot;PLAY&quot; command
    rtspClient-&gt;sendPlayCommand(*scs.session, continueAfterPLAY,
                                scs.session-&gt;absStartTime(),
                                scs.session-&gt;absEndTime());
  &#125; else &#123;
    scs.duration &#x3D; scs.session-&gt;playEndTime() - scs.session-&gt;playStartTime();
    rtspClient-&gt;sendPlayCommand(*scs.session, continueAfterPLAY);
  &#125;
&#125;

&#x2F;&#x2F; Callback function
void continueAfterSETUP(RTSPClient *rtspClient, int resultCode,
                        char *resultString) &#123;
  do &#123;
    &#x2F;&#x2F; Alias
    UsageEnvironment &amp;env &#x3D; rtspClient-&gt;envir();
    StreamClientState &amp;scs &#x3D; ((ourRTSPClient *)rtspClient)-&gt;scs;

    if (resultCode !&#x3D; 0) &#123;
      env &lt;&lt; *rtspClient &lt;&lt; &quot;Failed to set up the \&quot;&quot; &lt;&lt; *scs.subsession
          &lt;&lt; &quot;\&quot; subsession: &quot; &lt;&lt; resultString &lt;&lt; &quot;\n&quot;;
      break;
    &#125;

    env &lt;&lt; *rtspClient &lt;&lt; &quot;Set up the \&quot;&quot; &lt;&lt; *scs.subsession
        &lt;&lt; &quot;\&quot; subsession(&quot;;
    if (scs.subsession-&gt;rtcpIsMuxed()) &#123;
      env &lt;&lt; &quot;Client port &quot; &lt;&lt; scs.subsession-&gt;clientPortNum();
    &#125; else &#123;
      env &lt;&lt; &quot;Client ports &quot; &lt;&lt; scs.subsession-&gt;clientPortNum() &lt;&lt; &quot;-&quot;
          &lt;&lt; scs.subsession-&gt;clientPortNum() + 1;
    &#125;
    env &lt;&lt; &quot;)\n&quot;;

    &#x2F;&#x2F; Having successfully setup the subsession, create a data sink for it, and
    &#x2F;&#x2F; call &quot;startPlaying()&quot; on it. (This will prepare the data sink to receive
    &#x2F;&#x2F; data; the actual flow from the client won&#39;t start happening untill later
    &#x2F;&#x2F; after we&#39;ve sent an RTSP &quot;PLAY&quot; command.)

    &#x2F;&#x2F; Perhaps use your own custom &quot;MediaSink&quot; subclass instead
    scs.subsession-&gt;sink &#x3D;
        DummySink::createNew(env, *scs.subsession, rtspClient-&gt;url());

    if (scs.subsession-&gt;sink &#x3D;&#x3D; NULL) &#123;
      env &lt;&lt; *rtspClient &lt;&lt; &quot;Failed to create a data sink for the \&quot;&quot;
          &lt;&lt; *scs.subsession &lt;&lt; &quot;\&quot; subsession: &quot; &lt;&lt; env.getResultMsg() &lt;&lt; &quot;\n&quot;;
      break;
    &#125;

    env &lt;&lt; *rtspClient &lt;&lt; &quot;Create a data sink for the \&quot;&quot; &lt;&lt; *scs.subsession
        &lt;&lt; &quot;\&quot; subsession\n&quot;;
    scs.subsession-&gt;miscPtr &#x3D; rtspClient;
    scs.subsession-&gt;sink-&gt;startPlaying(*(scs.subsession-&gt;readSource()),
                                       subsessionAfterPlaying, scs.subsession);
    &#x2F;&#x2F; Also set a handler to be called if a RTSP &quot;BYE&quot; arrives for this
    &#x2F;&#x2F; subsession
    if (scs.subsession-&gt;rtcpInstance() !&#x3D; NULL) &#123;
      scs.subsession-&gt;rtcpInstance()-&gt;setByeWithReasonHandler(
          subsessionByeHandler, scs.subsession);
    &#125;
  &#125; while (0);
  delete[] resultString;

  &#x2F;&#x2F; Set up the next subsession, if any:
  setupNextSubsession(rtspClient);
&#125;

&#x2F;&#x2F; A callback function that is triggered after the RTSP client sends a PLAY
&#x2F;&#x2F; command and receives a response from the RTSP server
void continueAfterPLAY(RTSPClient *rtspClient, int resultCode,
                       char *resultString) &#123;
  Boolean success &#x3D; False;

  do &#123;
    &#x2F;&#x2F; Alias
    UsageEnvironment &amp;env &#x3D; rtspClient-&gt;envir();
    StreamClientState &amp;scs &#x3D; ((ourRTSPClient *)rtspClient)-&gt;scs;

    if (resultCode !&#x3D; 0) &#123;
      env &lt;&lt; *rtspClient &lt;&lt; &quot;Failed to start playing session: &quot; &lt;&lt; resultString
          &lt;&lt; &quot;\n&quot;;
      break;
    &#125;

    &#x2F;&#x2F; Set a timer to be handled at the end of the stream&#39;s expected duration
    &#x2F;&#x2F; (if the stream does not already signal its end using an RTSP &quot;BYE&quot;). This
    &#x2F;&#x2F; is optional. If, instead, you want to keep the stream active - e.g., so
    &#x2F;&#x2F; you can later &#39;seek&#39; back within it and do another RTSP &quot;PLAY&quot; - then you
    &#x2F;&#x2F; can omit this code. (Alternatively, if you don&#39;t want to receive the
    &#x2F;&#x2F; entire stream, you could set this timer for some shorter value) This
    &#x2F;&#x2F; ensures that the client handles the stream&#39;s end properly

    &#x2F;&#x2F; Btw, The duration won&#39;t be set if it&#39;s a live stream
    if (scs.duration &gt; 0) &#123;
      unsigned const delaySlop &#x3D;
          2; &#x2F;&#x2F; number of seconds extra to delay, after the stream&#39;s expected
             &#x2F;&#x2F; duration. (This is optional)
      scs.duration +&#x3D; delaySlop;
      unsigned uSecsToDelay &#x3D;
          (unsigned)(scs.duration * 1000000); &#x2F;&#x2F; Convert second into microsecond

      &#x2F;&#x2F; This schedules a task to be executed after the stream&#39;s duration has
      &#x2F;&#x2F; passed. The task scheduled here is stream streamTimerHandler, which is
      &#x2F;&#x2F; responsible for handling the stream&#39;s completion or timeout.
      scs.streamTimerTask &#x3D; env.taskScheduler().scheduleDelayedTask(
          uSecsToDelay, (TaskFunc *)streamTimerHandler, rtspClient);
    &#125;

    env &lt;&lt; *rtspClient &lt;&lt; &quot;Started playing session &quot;;
    if (scs.duration &gt; 0) &#123;
      env &lt;&lt; &quot; (for up to&quot; &lt;&lt; scs.duration &lt;&lt; &quot; seconds)&quot;;
    &#125;
    env &lt;&lt; &quot;...\n&quot;;

    success &#x3D; True;
  &#125; while (0);
  delete[] resultString;

  if (!success) &#123;
    shutdownStream(rtspClient);
  &#125;
&#125;

&#x2F;&#x2F; Implementation of the other event handlers

void subsessionAfterPlaying(void *clientData) &#123;
  &#x2F;&#x2F; Alias
  MediaSubsession *subsession &#x3D; (MediaSubsession *)clientData;
  RTSPClient *rtspClient &#x3D; (RTSPClient *)(subsession-&gt;miscPtr);

  &#x2F;&#x2F; Begin by closing the subsession&#39;s stream;
  Medium::close(subsession-&gt;sink);
  subsession-&gt;sink &#x3D; NULL;

  &#x2F;&#x2F; Next, check whether all subsessions&#39; streams have now been closed.
  MediaSession &amp;session &#x3D; subsession-&gt;parentSession();
  MediaSubsessionIterator iter(session);
  while ((subsession &#x3D; iter.next()) !&#x3D; NULL) &#123;
    &#x2F;&#x2F; This subsession is still active
    if (subsession-&gt;sink !&#x3D; NULL)
      return;
  &#125;

  &#x2F;&#x2F; Now, all the subsessions&#39; streams have been closed, so shutdown the client
  shutdownStream(rtspClient);
&#125;

void subsessionByeHandler(void *clientData, char const *reason) &#123;
  &#x2F;&#x2F; Alias
  MediaSubsession *subsession &#x3D; (MediaSubsession *)clientData;
  RTSPClient *rtspClient &#x3D; (RTSPClient *)subsession-&gt;miscPtr;
  UsageEnvironment &amp;env &#x3D; rtspClient-&gt;envir();

  env &lt;&lt; *rtspClient &lt;&lt; &quot;Received RTCP \&quot;BYE\&quot;&quot;;
  if (reason !&#x3D; NULL) &#123;
    env &lt;&lt; &quot; (reason:\&quot;&quot; &lt;&lt; reason &lt;&lt; &quot;\&quot;)&quot;;
    delete[] (char *)reason;
  &#125;
  env &lt;&lt; &quot; on \&quot;&quot; &lt;&lt; *subsession &lt;&lt; &quot;\&quot; subsession \n&quot;;

  &#x2F;&#x2F; Now act as if the subsession had closed
  subsessionAfterPlaying(subsession);
&#125;

void streamTimerHandler(void *clientData) &#123;
  &#x2F;&#x2F; Alias
  ourRTSPClient *rtspClient &#x3D; (ourRTSPClient *)clientData;
  StreamClientState &amp;scs &#x3D; rtspClient-&gt;scs;

  scs.streamTimerTask &#x3D; NULL;

  &#x2F;&#x2F; Shut down the stream;
  shutdownStream(rtspClient);
&#125;

void shutdownStream(RTSPClient *rtspClient, int exitCode) &#123;
  &#x2F;&#x2F; Alias
  UsageEnvironment &amp;env &#x3D; rtspClient-&gt;envir();
  StreamClientState &amp;scs &#x3D; ((ourRTSPClient *)rtspClient)-&gt;scs;

  &#x2F;&#x2F; First, check whether any subsessions have still to be closed;
  if (scs.session !&#x3D; NULL) &#123;
    Boolean someSubsessionsWereActive &#x3D; False;
    MediaSubsessionIterator iter(*scs.session);
    MediaSubsession *subsession;

    while ((subsession &#x3D; iter.next()) !&#x3D; NULL) &#123;
      if (subsession-&gt;sink !&#x3D; NULL) &#123;
        Medium::close(subsession-&gt;sink);
        subsession-&gt;sink &#x3D; NULL;

        &#x2F;&#x2F; In case the server sends a RTCP &quot;BYE&quot; while handling &quot;TEARDOWN&quot;
        if (subsession-&gt;rtcpInstance() !&#x3D; NULL) &#123;
          subsession-&gt;rtcpInstance()-&gt;setByeHandler(NULL, NULL);
        &#125;
        someSubsessionsWereActive &#x3D; True;
      &#125;
    &#125;

    if (someSubsessionsWereActive) &#123;
      &#x2F;&#x2F; Send an RTSP &quot;TEARDOWN&quot; command to tell the server to shutdown the
      &#x2F;&#x2F; stream. Don&#39;t bother handling the response to the &quot;TEARDOWN&quot;.
      rtspClient-&gt;sendTeardownCommand(*scs.session, NULL);
    &#125;
  &#125;

  env &lt;&lt; *rtspClient &lt;&lt; &quot;Closing the stream. \n&quot;;
  Medium::close(rtspClient);

  if (--rtspClientCount &#x3D;&#x3D; 0) &#123;

    exit(exitCode);
  &#125;
&#125;

&#x2F;&#x2F; Implementation of &quot;ourRTSPClient&quot;:

ourRTSPClient *ourRTSPClient::createNew(UsageEnvironment &amp;env,
                                        char const *rtspURL, int verbosityLevel,
                                        char const *applicationName,
                                        portNumBits tunnelOverHTTPPortNum) &#123;
  return new ourRTSPClient(env, rtspURL, verbosityLevel, applicationName,
                           tunnelOverHTTPPortNum);
&#125;

ourRTSPClient::ourRTSPClient(UsageEnvironment &amp;env, char const *rtspURL,
                             int verbosityLevel, char const *applicationName,
                             portNumBits tunnelOverHTTPPortNum)
    : RTSPClient(env, rtspURL, verbosityLevel, applicationName,
                 tunnelOverHTTPPortNum, -1) &#123;&#125;

ourRTSPClient::~ourRTSPClient() &#123;
  is_run1 &#x3D; False;
  is_run2 &#x3D; False;
  is_run3 &#x3D; False;
  cv1.notify_all();
  cv2.notify_all();
  cv3.notify_all();
&#125;

&#x2F;&#x2F; Implementation of &quot;StreamClientState&quot; :

StreamClientState::StreamClientState()
    : iter(NULL), session(NULL), subsession(NULL), streamTimerTask(NULL),
      duration(0.0) &#123;&#125;

StreamClientState::~StreamClientState() &#123;
  delete iter;
  if (session !&#x3D; NULL) &#123;
    &#x2F;&#x2F; We also need to delete &quot;session&quot;, and unschedule &quot;steamTimerTask&quot; (if
    &#x2F;&#x2F; set) Alias
    UsageEnvironment &amp;env &#x3D; session-&gt;envir();

    env.taskScheduler().unscheduleDelayedTask(streamTimerTask);
    Medium::close(session);
  &#125;
&#125;

&#x2F;&#x2F; Implementation of &quot;DummySink&quot;

&#x2F;&#x2F; Even though we&#39;re not going to be doing anything with the incoming data, we
&#x2F;&#x2F; still need to receive it. Define the size of the buffer that we&#39;ll use:
#define DUMMY_SINK_RECEIVE_BUFFER_SIZE 1000000

DummySink *DummySink::createNew(UsageEnvironment &amp;env,
                                MediaSubsession &amp;subsession,
                                char const *streamId) &#123;
  return new DummySink(env, subsession, streamId);
&#125;

DummySink::DummySink(UsageEnvironment &amp;env, MediaSubsession &amp;subsession,
                     char const *streamId)
    : MediaSink(env), fSubsession(subsession) &#123;
  fStreamId &#x3D; strDup(streamId);
  fReceiveBuffer &#x3D; new u_int8_t[DUMMY_SINK_RECEIVE_BUFFER_SIZE];

  std::string fileName &#x3D; &quot;.&#x2F;save&#x2F;output_&quot; + oss.str() + &quot;.h264&quot;;
  fOutputFile &#x3D; fopen(fileName.c_str(), &quot;wb&quot;);
&#125;

DummySink::~DummySink() &#123;
  fclose(fOutputFile);
  delete[] fReceiveBuffer;
  delete[] fStreamId;
&#125;

void DummySink::afterGettingFrame(void *clientData, unsigned frameSize,
                                  unsigned numTruncatedBytes,
                                  struct timeval presentationTime,
                                  unsigned durationInMicroseconds) &#123;
  DummySink *sink &#x3D; (DummySink *)clientData;
  sink-&gt;afterGettingFrame(frameSize, numTruncatedBytes, presentationTime,
                          durationInMicroseconds);
&#125;

&#x2F;&#x2F; If you don&#39;t wanna see debugging output for each received frame, then comment
&#x2F;&#x2F; out the following line:
#define DEBUG_PRINT_EACH_RECEIVED_FRAME 1

void DummySink::afterGettingFrame(unsigned frameSize,
                                  unsigned numTruncatedBytes,
                                  struct timeval presentationTime,
                                  unsigned durationInMicroseconds) &#123;
  &#x2F;&#x2F; We&#39;ve just received a frame of data. (Optionally) print out information
  &#x2F;&#x2F; about it:
#ifdef DEBUG_PRINT_EACH_RECEIVED_FRAME
  if (fStreamId !&#x3D; NULL)
    envir() &lt;&lt; &quot;Stream \&quot;&quot; &lt;&lt; fStreamId &lt;&lt; &quot;\&quot;;&quot;;
  envir() &lt;&lt; fSubsession.mediumName() &lt;&lt; &quot;&#x2F;&quot; &lt;&lt; fSubsession.codecName()
          &lt;&lt; &quot;:\tReceived &quot; &lt;&lt; frameSize &lt;&lt; &quot; bytes&quot;;
  if (numTruncatedBytes &gt; 0)
    envir() &lt;&lt; &quot; (with &quot; &lt;&lt; numTruncatedBytes &lt;&lt; &quot;bytes truncated&quot;;
  char uSecsStr[6 + 1];
  snprintf(uSecsStr, sizeof(uSecsStr), &quot;%06u&quot;,
           (unsigned)presentationTime.tv_usec);
  envir() &lt;&lt; &quot;.\tPresentation time: &quot; &lt;&lt; (int)presentationTime.tv_sec &lt;&lt; &quot;.&quot;
          &lt;&lt; uSecsStr;

  if (fSubsession.rtpSource() !&#x3D; NULL &amp;&amp;
      !fSubsession.rtpSource()-&gt;hasBeenSynchronizedUsingRTCP()) &#123;
    envir() &lt;&lt; &quot;!&quot;;
  &#125;

#ifdef DEBUG_PRINT_NPT
  envir() &lt;&lt; &quot;\tNPT: &quot; &lt;&lt; fSubsession.getNormalPlayTime(presentationTime);
#endif
  envir() &lt;&lt; &quot;\n&quot;;
#endif
  count264++;
  if(count264 &lt;&#x3D; maxFrame)
    fwrite(fReceiveBuffer, 1, frameSize, fOutputFile);
  uint8_t *copyData &#x3D; new uint8_t[frameSize];
  memmove(copyData, fReceiveBuffer, frameSize);
  std::unique_lock&lt;std::mutex&gt; lock1(mutex1);
  queue264.push(std::make_pair(copyData, frameSize));
  cv1.notify_one();
  continuePlaying();
&#125;

Boolean DummySink::continuePlaying() &#123;
  if (fSource &#x3D;&#x3D; NULL)
    return False;

  fSource-&gt;getNextFrame(fReceiveBuffer, DUMMY_SINK_RECEIVE_BUFFER_SIZE,
                        afterGettingFrame, this, onSourceClosure, this);

  return True;
&#125;

void thread_decode() &#123;

  &#x2F;&#x2F; Initialize the decode environment
  int id &#x3D; 0;
  int result;
  set &#x3D; True;

  const AVCodec *codec &#x3D; avcodec_find_decoder(AV_CODEC_ID_H264);
  if (!codec) &#123;
    std::cerr &lt;&lt; &quot;Failed to find the decoder&quot; &lt;&lt; std::endl;
    return;
  &#125;

  AVCodecContext *ctx &#x3D; avcodec_alloc_context3(codec);
  if (!ctx) &#123;
    std::cerr &lt;&lt; &quot;Failed to allocate video codec context&quot; &lt;&lt; std::endl;
    return;
  &#125;

  if (avcodec_open2(ctx, codec, nullptr) &lt; 0) &#123;
    std::cerr &lt;&lt; &quot;Couldn&#39;t open the codec!&quot; &lt;&lt; std::endl;
    avcodec_free_context(&amp;ctx);
    return;
  &#125;

  AVPacket *pkt &#x3D; av_packet_alloc();

  uint8_t *data;
  int size;
  while (1) &#123;

    std::unique_lock&lt;std::mutex&gt; lock1(mutex1);
    cv1.wait(lock1, []() &#123; return !queue264.empty(); &#125;);
    if (!is_run1)
      break;
    auto nalData &#x3D; queue264.front();
    queue264.pop();
    data &#x3D; nalData.first;
    size &#x3D; nalData.second;

    pkt-&gt;data &#x3D; data;
    pkt-&gt;size &#x3D; size;

    result &#x3D; avcodec_send_packet(ctx, pkt);

    if (result &lt; 0) &#123;
      std::cerr &lt;&lt; &quot;Error sending packet for decoding&quot; &lt;&lt; std::endl;
      continue;
    &#125;

    while (1) &#123;

      AVFrame *frame &#x3D; av_frame_alloc();
      result &#x3D; avcodec_receive_frame(ctx, frame);
      if (result &#x3D;&#x3D; AVERROR(EAGAIN) || result &#x3D;&#x3D; AVERROR_EOF || result &lt; 0) &#123;
        av_frame_free(&amp;frame);
        break;
      &#125;

      if (set) &#123;
        std::unique_lock&lt;std::mutex&gt; lockS(m_set);
        fd.height &#x3D; frame-&gt;height;
        fd.width &#x3D; frame-&gt;width;
        fd.format &#x3D; static_cast&lt;AVPixelFormat&gt;(frame-&gt;format);
        set &#x3D; False;
        cv_set.notify_one();
      &#125;
      id++;
      std::cout &lt;&lt; &quot;Decode frame:&quot; &lt;&lt; id &lt;&lt; &quot; Width: &quot; &lt;&lt; frame-&gt;width
                &lt;&lt; &quot; Height: &quot; &lt;&lt; frame-&gt;height &lt;&lt; std::endl;

      std::unique_lock&lt;std::mutex&gt; lock2(mutex2);
      queueFrame.push(frame);
      cv2.notify_one();
    &#125;
    delete[] data;
    data &#x3D; nullptr;
  &#125;
  av_packet_free(&amp;pkt);
  avcodec_free_context(&amp;ctx);
&#125;

void thread_codec() &#123;

  int result;
  const AVCodec *codec &#x3D; avcodec_find_encoder(AV_CODEC_ID_HEVC);
  if (!codec) &#123;
    std::cerr &lt;&lt; &quot;Failed to find the encoder!&quot; &lt;&lt; std::endl;
    return;
  &#125;

  AVCodecContext *ctx &#x3D; avcodec_alloc_context3(codec);
  if (!ctx) &#123;
    std::cerr &lt;&lt; &quot;Failed to allocate video codec context!&quot; &lt;&lt; std::endl;
    return;
  &#125;

  std::unique_lock&lt;std::mutex&gt; lockS(m_set);
  cv_set.wait(lockS, []() &#123; return !set; &#125;);
  ctx-&gt;width &#x3D; fd.width;
  ctx-&gt;height &#x3D; fd.height;
  ctx-&gt;pix_fmt &#x3D; fd.format;
  ctx-&gt;time_base.num &#x3D; 1;
  ctx-&gt;time_base.den &#x3D; 25;

  if (avcodec_open2(ctx, codec, NULL) &lt; 0) &#123;
    std::cerr &lt;&lt; &quot;Couldn&#39;t open codec&quot; &lt;&lt; std::endl;
    return;
  &#125;

  AVFrame *frame;
  while (1) &#123;

    std::unique_lock&lt;std::mutex&gt; lock2(mutex2);
    cv2.wait(lock2, []() &#123; return !queueFrame.empty(); &#125;);
    if (!is_run2)
      break;
    frame &#x3D; queueFrame.front();
    queueFrame.pop();

    if (avcodec_send_frame(ctx, frame) &lt; 0) &#123;
      std::cerr &lt;&lt; &quot;Error sending a frame for encoding&quot; &lt;&lt; std::endl;
      continue;
    &#125;

    while (1) &#123;
      AVPacket *pkt &#x3D; av_packet_alloc();
      result &#x3D; avcodec_receive_packet(ctx, pkt);
      if (result &#x3D;&#x3D; AVERROR(EAGAIN) || result &#x3D;&#x3D; AVERROR_EOF || result &lt; 0) &#123;
        av_packet_free(&amp;pkt);
        break;
      &#125;
      uint8_t *data &#x3D; new uint8_t[pkt-&gt;size];
      memmove(data, pkt-&gt;data, pkt-&gt;size);
      int size &#x3D; pkt-&gt;size;
      av_packet_free(&amp;pkt);
      std::unique_lock&lt;std::mutex&gt; lock3(mutex3);
      queue265.push(std::make_pair(data, size));
      cv3.notify_one();
    &#125;
    av_frame_free(&amp;frame);
  &#125;
  avcodec_free_context(&amp;ctx);
&#125;

void thread_save() &#123;

  int count &#x3D; 0;
  FILE *h265;
  std::string fileName &#x3D; &quot;.&#x2F;save&#x2F;output_&quot; + oss.str() + &quot;.h265&quot;;
  h265 &#x3D; fopen(fileName.c_str(), &quot;wb&quot;);

  while (1) &#123;
    std::unique_lock&lt;std::mutex&gt; lock3(mutex3);
    cv3.wait(lock3, []() &#123; return !queue265.empty(); &#125;);
    if (!is_run3)
      break;
    auto data265 &#x3D; queue265.front();
    queue265.pop();
    uint8_t *data &#x3D; data265.first;
    int size &#x3D; data265.second;
    count++;
    fwrite(data, 1, size, h265);
    if(count &#x3D;&#x3D; maxFrame) exit(0);
    delete[] data;
  &#125;
  fclose(h265);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

      <div class="tags">
          <a href="/tags/live555-ffmpeg/" rel="tag"><i class="ic i-tag"></i> live555, ffmpeg</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2024-10-18 17:07:48" itemprop="dateModified" datetime="2024-10-18T17:07:48+09:00">2024-10-18</time>
  </span>
</div>

      
<div class="reward">
  <checkbox><i class="ic i-heartbeat"></i> Donate</checkbox>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="Sunday WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="Sunday Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="Sunday PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Sunday <i class="ic i-at"><em>@</em></i>Sunday
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://hexlove2.github.io/2024/10/11/Notes/live555usage/" title="Live555 Usage(FFmpeg)">http://hexlove2.github.io/2024/10/11/Notes/live555usage/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2024/09/13/Notes/Cmake/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Hexlove2&#x2F;images1&#x2F;main&#x2F;images2&#x2F;24.jpg" title="Project Building Notes">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> Notes</span>
  <h3>Project Building Notes</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2025/02/18/Projects/httpserver/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Hexlove2&#x2F;images1&#x2F;main&#x2F;images2&#x2F;15.jpg" title="Http Linux Server">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> Projects</span>
  <h3>Http Linux Server</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#platform-win10-macos15"><span class="toc-number">1.</span> <span class="toc-text"> Platform: Win10 &amp; MacOS15</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reference-ffmpeg-live555"><span class="toc-number">2.</span> <span class="toc-text"> Reference: FFMPEG, LIVE555</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-source-code-download-link-httpsgithubcomrgaufmanlive555"><span class="toc-number">3.</span> <span class="toc-text"> 1. Source Code Download Link: https:&#x2F;&#x2F;github.com&#x2F;rgaufman&#x2F;live555</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-build"><span class="toc-number">4.</span> <span class="toc-text"> 2. Build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-usages"><span class="toc-number">5.</span> <span class="toc-text"> 3. Usages</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-push-local-audio-and-video-files-stream-to-an-rtsp-server"><span class="toc-number">5.1.</span> <span class="toc-text"> 1. Push local audio and video files’ stream to an RTSP server.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-push-the-camera-stream-to-an-rtsp-server"><span class="toc-number">5.2.</span> <span class="toc-text"> 2. Push the camera stream to an RTSP server.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-rtsp-client-receive-rtsp-stream-data-in-h264-format-and-re-encode-it-into-h265"><span class="toc-number">5.3.</span> <span class="toc-text"> 3. RTSP Client: Receive RTSP stream data in H.264 format and re-encode it into H.265</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li><a href="/2023/01/09/Notes/Csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="bookmark" title="C#初级笔记">C#初级笔记</a></li><li><a href="/2024/02/29/Notes/Socket%20learning/" rel="bookmark" title="TCP/IP Socket Coding">TCP/IP Socket Coding</a></li><li><a href="/2024/07/07/Notes/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="Interview Questions">Interview Questions</a></li><li><a href="/2024/08/10/Notes/The%20Elements%20of%20Statistical%20Learning/" rel="bookmark" title="Statistical Learning">Statistical Learning</a></li><li><a href="/2024/09/13/Notes/Cmake/" rel="bookmark" title="Project Building Notes">Project Building Notes</a></li><li class="active"><a href="/2024/10/11/Notes/live555usage/" rel="bookmark" title="Live555 Usage(FFmpeg)">Live555 Usage(FFmpeg)</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Sunday"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Sunday</p>
  <div class="description" itemprop="description">Later's better than never</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">22</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">5</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">13</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hleGxvdmUy" title="https:&#x2F;&#x2F;github.com&#x2F;Hexlove2"><i class="ic i-github"></i></span>
      <a href="/hexlove@163.com" title="hexlove@163.com" class="item email"><i class="ic i-envelope"></i></a>
      <span class="exturl item youtube" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vQFlpaGFuZ1h1MA==" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;@YihangXu0"><i class="ic i-youtube"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

    
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-moon"></i>Art</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/paint/" rel="section"><i class="ic i-sun"></i>Paint</a>
  </li>

  </ul>
        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-sakura"></i>Demo</a>
    <ul class="submenu">

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2024/09/13/Notes/Cmake/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2025/02/18/Projects/httpserver/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Notes/" title="In Notes">Notes</a>
</div>

    <span><a href="/2023/01/09/Notes/Csharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C#初级笔记">C#初级笔记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Coding/" title="In Coding">Coding</a>
</div>

    <span><a href="/2022/12/05/Coding/Unity+Git/" title="Unity+Git">Unity+Git</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Coding/" title="In Coding">Coding</a>
</div>

    <span><a href="/2024/07/22/Coding/PjSip_Usage/" title="Usage of PjSip">Usage of PjSip</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Coding/" title="In Coding">Coding</a>
</div>

    <span><a href="/2024/09/05/Coding/Imageprocess/" title="Image Processing Algorithm(Raw Data)">Image Processing Algorithm(Raw Data)</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Notes/" title="In Notes">Notes</a>
</div>

    <span><a href="/2024/07/07/Notes/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Interview Questions">Interview Questions</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Journey/" title="In Journey">Journey</a>
</div>

    <span><a href="/2022/10/29/Journey/hexo/" title="关于Hexo s显示正常但Hexo d没有更新内容的问题">关于Hexo s显示正常但Hexo d没有更新内容的问题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Projects/" title="In Projects">Projects</a>
</div>

    <span><a href="/2077/07/26/Projects/blogupdatelog/" title="Blog Changelog">Blog Changelog</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Notes/" title="In Notes">Notes</a>
</div>

    <span><a href="/2024/10/11/Notes/live555usage/" title="Live555 Usage(FFmpeg)">Live555 Usage(FFmpeg)</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Notes/" title="In Notes">Notes</a>
</div>

    <span><a href="/2024/09/13/Notes/Cmake/" title="Project Building Notes">Project Building Notes</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Projects/" title="In Projects">Projects</a>
</div>

    <span><a href="/2025/02/18/Projects/httpserver/" title="Http Linux Server">Http Linux Server</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sunday @ Hex</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2024/10/11/Notes/live555usage/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
